
--------------------------------
-- TODO
--------------------------------

* Scaffold:
	X Collection
	X Content Type
	X Category
	X Entry
	X Link
	X Person
	X Workspace
	
* Establish Relations between Entities
	- All but composition of Entry and Content finished: need to reearch
	- See: http://msdn.microsoft.com/en-us/library/bb738472.aspx (Complex Types)
		- Perhaps that is relevant for Links as well...

* NOT Scaffolded: (Singleton or transient!)
	- Generator
	- Feed
	- Service

* Serialization
	- Attributes to define serialization more explicitly
	- Need to distinguish between XML and other serialization forms
		- some properties are merely content of an element, and thus have no name
		- some properties are attributes vs. elements
		- some properties will need to be nested under a collection name, others merely listed as
		  individual entities.
		- some properties which we associate with a parent entity will actually be attached as
		  attributes/elements of children (such as Collection's "AreCategoriesFixed" property)
		- some properties are in an explicit namespace
	- Would it make more sense to perform an XML transformation?
		- We'd still need to render it into a known preliminary XML format to do that conversion
		- However, if we did have a known preliminary format, we could then transform both for JSON and Atom (as well as others: HTML page rendering for example, though in that case a View is more prudent for our purposes)
		- There would still be concerns with reuse: we'd want to reuse XSL transformations for representations, but we'd also still need to prevent recursive descent further than the document would allow in the standard (and further than we'd want to for efficiency and relevancy purposes)
			- Intermediate XML format could have attributes used to determine whether descent is desired, generated by the SerializationDescend properties.
	- Can we use cshtml Razor rendered views to render XML or JSON?
		- Perhaps with custom view engine

* Extending MvcScaffolding to scaffold JSON and XML views
	- Look under packages/MvcScaffolding.0.9.1/tools
	- .ps1 files appear to provide the logic to determine what templates should be rendered, and sets variables that are used when rendering templates
		- .ps1 is apparently PowerShell Script, makes sense as its executed through NuGet
	- Controller/MvcScaffolding.Controller.ps1
		- Invokes the "Scaffold Views" command
		- Conveniently, since we have modified our ViewModel we don't need to modify the Controller to get the desired output type
	- View/MvcScaffolding.Views.ps1
		- Loops through the types of views its creating, and calls a configured ViewScaffolder
			- Implied to be Razor from install.ps1 unless a standard ASPX view already exists in project
		- Ends up, as a result, calling RazorView/MvcScaffolding.RazorView.ps1 for each view to generate
	- RazorView/MvcScaffolding.RazorView.ps1
		- By this point, we need to know not only what we're already passed, but also the sub-path (aka type) so we can determine both output folder locations and input template paths relative to the normal path to look.
		- In short, we must pass RazorView.ps1 the "type" in addition to the "template name" in Views.ps1, and modify RazorView.ps1 to use the new path.
	- Syntax
		- I can imply that "@("Create", "Edit", "Delete", "Details", "Index") | %{ ... }" is a foreach-like loop construct, and that $_ is the variable being populated by the loop... is there a way to change what the name of the variable being populated is? (See Views.ps1 for an example)
		- It also looks like variables can be declared on the fly simply by assigning a new value to the variable (see RazorView.ps1 for example)
		- Changing output path was easy: changing path to search for template not so much (wasn't clear what kind of path was being passed in: it's an array of paths, but are they relative?  Absolute?  Need to hunt down source or find a way to debug.
			- Find-ScaffolderTemplate holds the key to how it is used.  Grabbed source, will inspect.
			
			
* Creating an addon to use MvcScaffolding
	- Figure out how to/if I can easily integrate with existing commands
		- If not, figure out how/if I have to do anything special to invoke its commands safely
	- Figure out how to turn it into a proper NuGet package
	- Figure out how to deploy it locally
	
	
* Partial Views -> Atom
	- 